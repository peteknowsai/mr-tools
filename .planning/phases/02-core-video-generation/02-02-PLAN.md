---
phase: 02-core-video-generation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - tools/nanobanana/video.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Video generation can be triggered programmatically"
    - "Tool polls for completion and detects when video is ready"
    - "Video can be downloaded to local filesystem"
    - "Job ID is returned for status tracking"
  artifacts:
    - path: "tools/nanobanana/video.py"
      provides: "Async video generation, polling, and retrieval"
      exports: ["generate_video"]
      min_lines: 150
  key_links:
    - from: "tools/nanobanana/video.py"
      to: "tools/nanobanana/nanobanana.py"
      via: "Import load_cookies for cookie-based auth"
      pattern: "from nanobanana import load_cookies"
    - from: "tools/nanobanana/video.py"
      to: "httpx AsyncClient"
      via: "Direct HTTP requests"
      pattern: "httpx.AsyncClient"
---

<objective>
Build the video generation module with async trigger, polling, and retrieval.

Purpose: Implement core video generation functionality using the API format captured in Plan 01. This module will handle the complete async lifecycle: trigger -> poll -> retrieve.

Output: tools/nanobanana/video.py with generate_video() function that returns video file path and job_id.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-video-generation/02-API-CAPTURE.md
@.planning/phases/02-core-video-generation/02-01-SUMMARY.md
@tools/nanobanana/nanobanana.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create video.py module structure</name>
  <files>tools/nanobanana/video.py</files>
  <action>
Create the video generation module with the following structure:

```python
#!/usr/bin/env python3
"""
video.py - Video generation using Gemini Veo via web interface

Uses cookie-based auth from your Google AI Pro subscription.
Handles async video generation lifecycle: trigger -> poll -> retrieve.
"""

import asyncio
import sys
import time
from pathlib import Path

import httpx

# Import from nanobanana for shared utilities
from nanobanana import (
    load_cookies,
    parse_streaming_response,
    unpack_nested_json,
    CONFIG_DIR,
)

# Video-specific config
DEFAULT_VIDEO_DIR = CONFIG_DIR / "videos"

# Gemini endpoints (update from 02-API-CAPTURE.md)
GEMINI_HOST = "gemini.google.com"
STREAM_GENERATE_URL = f"https://{GEMINI_HOST}/_/BardChatUi/data/assistant.lamda.BardFrontendService/StreamGenerate"

# Video model header - FROM 02-API-CAPTURE.md
# This is the key difference from image generation
VIDEO_MODEL_HEADER = {
    "x-goog-ext-525001261-jspb": "TBD - fill from 02-API-CAPTURE.md"
}

# Duration options (in seconds)
DURATION_OPTIONS = [4, 6, 8]

# Aspect ratio options
ASPECT_RATIOS = ["16:9", "9:16"]
```

Fill in VIDEO_MODEL_HEADER with the actual value from 02-API-CAPTURE.md.

Add any additional constants discovered during API capture (idx parameters, polling endpoints, etc.).
  </action>
  <verify>python3 -c "import sys; sys.path.insert(0, 'tools/nanobanana'); import video; print('Module imports OK')"</verify>
  <done>video.py module structure created with constants from API capture</done>
</task>

<task type="auto">
  <name>Task 2: Implement generate_video function with polling</name>
  <files>tools/nanobanana/video.py</files>
  <action>
Add the main generate_video() async function with full lifecycle:

```python
async def generate_video(
    prompt: str,
    output_dir: Path = None,
    filename: str = None,
    duration: int = 8,
    aspect_ratio: str = "16:9",
    timeout: int = 600,
    debug: bool = False
) -> dict:
    """
    Generate a video using Gemini Veo.

    Args:
        prompt: Video description
        output_dir: Where to save video (default: ~/.nanobanana/videos/)
        filename: Custom filename without extension
        duration: Video length in seconds (4, 6, or 8)
        aspect_ratio: "16:9" (landscape) or "9:16" (portrait)
        timeout: Max wait time in seconds (default: 10 minutes)
        debug: Show debug output

    Returns:
        dict with job_id, status, filepath (on success), or error message
        Success: {"status": "complete", "job_id": "video_YYYYMMDD_HHMMSS", "filepath": "/path/to/video.mp4", "elapsed_seconds": N}
        Error: {"status": "error", "job_id": "video_YYYYMMDD_HHMMSS", "error": "message"}
    """
```

Implementation pattern (adapt based on 02-API-CAPTURE.md findings):

1. **Authentication** (reuse nanobanana pattern):
   - Load cookies from ~/.nanobanana/cookies.json using `load_cookies()` from nanobanana.py
   - Build cookie header and extract access_token from page request
   - NO GeminiClient - use direct cookie-based auth like nanobanana.py does

2. **Generate job_id**:
   - Create unique job_id using format: `video_YYYYMMDD_HHMMSS`
   - This is returned immediately for status tracking

3. **Trigger video generation**:
   - Build request body with video parameters
   - Send POST request with VIDEO_MODEL_HEADER
   - Parse response for completion status or poll reference

4. **Poll for completion** (if async):
   - Implement polling loop with progress display
   - Print elapsed time to stderr every 10 seconds
   - Check for completion indicator in response
   - Respect timeout parameter

5. **Retrieve video**:
   - Extract video URL from completion response
   - Download video to output_dir
   - Save with .mp4 extension

6. **Return result with job_id**:
   - Success: {"status": "complete", "job_id": "video_...", "filepath": "/path/to/video.mp4", "elapsed_seconds": N}
   - Error: {"status": "error", "job_id": "video_...", "error": "message"}
   - Timeout: {"status": "timeout", "job_id": "video_...", "error": "Generation timed out after N seconds"}

Key patterns from nanobanana.py to reuse:
- lines 89-97: load_cookies() - direct cookie loading, no GeminiClient
- lines 99-115: build_request_body() (adapt for video params)
- lines 118-175: parse_streaming_response() and unpack_nested_json()
- lines 321-326: httpx streaming pattern

Add progress display during polling:
```python
elapsed = int(time.time() - start_time)
print(f"Generating video... {elapsed}s elapsed", file=sys.stderr)
```
  </action>
  <verify>python3 -c "import sys; sys.path.insert(0, 'tools/nanobanana'); from video import generate_video; print('Function defined OK')"</verify>
  <done>generate_video() function implemented with trigger, polling, retrieval, and job_id in return</done>
</task>

<task type="auto">
  <name>Task 3: Add helper functions and error handling</name>
  <files>tools/nanobanana/video.py</files>
  <action>
Add helper functions for building video requests and extracting video URLs:

1. **generate_job_id()** - Create unique job identifier:
   - Format: `video_YYYYMMDD_HHMMSS`
   - Uses datetime.now().strftime()

2. **build_video_request_body()** - Similar to nanobanana's build_request_body but with video-specific parameters:
   - Duration parameter (4, 6, or 8 seconds)
   - Aspect ratio parameter (16:9 or 9:16)
   - Use idx parameters from 02-API-CAPTURE.md

3. **extract_video_url()** - Parse response to find video URL:
   - Recursively search response structure
   - Look for video URL patterns (may differ from image URLs)
   - Handle both immediate and polled response formats

4. **validate_params()** - Check duration and aspect ratio are valid:
   - Duration must be in [4, 6, 8]
   - Aspect ratio must be "16:9" or "9:16"
   - Return helpful error messages

Add error handling for:
- Cookie expiration (suggest running --setup)
- Rate limiting (explain daily limit)
- Content policy rejection (suggest prompt revision)
- Timeout (include job_id for manual retry: "Timed out. Job ID: video_... for manual retry")
- HTTP errors (include status code and reason)

Ensure all stderr output uses print(..., file=sys.stderr) for clean stdout/JSON mode.
  </action>
  <verify>python3 -c "import sys; sys.path.insert(0, 'tools/nanobanana'); from video import build_video_request_body, extract_video_url; print('Helpers defined OK')"</verify>
  <done>Helper functions and comprehensive error handling added</done>
</task>

</tasks>

<verification>
- video.py exists and imports correctly
- generate_video() function is defined with correct signature
- Module uses direct cookie loading from nanobanana.py (not gemini-webapi GeminiClient)
- Return dict includes job_id in all cases (success, error, timeout)
- Polling loop displays elapsed time to stderr
- Video downloads to local filesystem
- Error messages are clear and actionable
</verification>

<success_criteria>
Running the following test produces a video file with job_id:
```python
import asyncio
from video import generate_video
result = asyncio.run(generate_video("ocean waves at sunset", debug=True))
print(result)
# Expected: {"status": "complete", "job_id": "video_20260119_123045", "filepath": "~/.nanobanana/videos/timestamp.mp4", "elapsed_seconds": 45}
```
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-video-generation/02-02-SUMMARY.md`
</output>
